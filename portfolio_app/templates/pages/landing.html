{% extends 'base.html' %}

{% block content %}
  <div id="landing" class="fixed inset-0 h-screen w-full pt-1 sm:pt-32 px-6 sm:px-10 text-center bg-gradient-to-br from-bg_dark to-[#0a0636b8] text-quinary overflow-hidden">
    <!-- Animated Background Elements -->
    <div class="absolute inset-0 overflow-hidden z-0 pointer-events-none">
      {% for i in xxxxxxxxxx %}
        <div class="floating-particle absolute w-1.5 h-1.5 bg-secondary rounded-full opacity-20" style="top: {{ forloop.counter|add:5 }}%; left: {{ forloop.counter|add:10 }}%; 
                    animation: float-particle {{ 10|add:forloop.counter }}s ease-in-out infinite;
                    filter: blur(0.5px);"></div>
      {% endfor %}

      <!-- Subtle animated gradient circles -->
      <div class="absolute -bottom-1/4 -left-1/4 w-[150%] h-[150%] rounded-full bg-gradient-to-tr from-warning/5 to-secondary/5 animate-spin-slow opacity-20 blur-xl"></div>
      <div class="absolute -top-1/4 -right-1/4 w-[120%] h-[120%] rounded-full bg-gradient-to-br from-warning/3 to-secondary/3 animate-spin-slower opacity-15 blur-xl"></div>

      <!-- Subtle grid overlay -->
      <div class="absolute inset-0 opacity-5 bg-grid-pattern bg-[length:50px_50px]"></div>
    </div>

    <!-- Hero Section -->
    <div class="relative z-20 h-full flex flex-col justify-center items-center pb-40">
      <div class="flex gap-2 text-5xl sm:text-6xl md:text-8xl font-extrabold justify-center">
        <p data-aos="fade-right" data-aos-offset="300" data-aos-easing="ease-in-sine" data-aos-duration="1200" class="text-transparent bg-clip-text py-3 bg-gradient-to-r from-warning to-secondary">{{ profile.first_name }}</p>
        <p data-aos="fade-left" data-aos-offset="300" data-aos-easing="ease-in-sine" data-aos-duration="1200" class="text-transparent bg-clip-text py-3 bg-gradient-to-r from-secondary to-warning">{{ profile.last_name }}</p>
      </div>

      <div id="hero-text" class="relative z-10 mb-16 max-w-4xl mx-auto">
        <h2 data-aos="zoom-out-down" data-aos-duration="1500" data-aos-delay="500" class="text-xl sm:text-2xl md:text-3xl font-medium text-quinary/90 mt-8 tracking-wide"><span class="inline-block bg-gradient-to-r from-warning/70 to-secondary/70 bg-clip-text text-transparent">{{ profile.heading }}</span></h2>
        <p data-aos="fade-up" data-aos-duration="1500" data-aos-delay="800" class="text-lg sm:text-xl text-quinary/80 mt-6 font-light tracking-wider">
          <span class="inline-block px-4 py-2 rounded-full bg-white/5 backdrop-blur-sm border border-white/10">Based in AA, Ethiopia</span>
        </p>
      </div>

      <!-- Interactive Skills Section -->
      <div id="skills-container" class="absolute inset-0 w-full h-full overflow-hidden pointer-events-auto">
        {% for skill in skills %}
          {% if skill.logo %}
            <div class="floating-skill absolute cursor-grab active:cursor-grabbing z-20 transition-all duration-500" data-skill-id="{{ forloop.counter }}" data-aos="zoom-in" data-aos-delay="{{ forloop.counter }}00">
              <div class="relative group transform transition-all duration-500 hover:scale-125">
                <div class="w-12 h-12 sm:w-16 sm:h-16 flex items-center justify-center p-3 rounded-full shadow-lg bg-white/5 backdrop-blur-md border border-white/10 group-hover:border-warning/50 transition-all animate-float hover:shadow-warning/10">
                  <img src="{{ skill.logo.url }}" alt="{{ skill.name }}" class="w-full h-full object-contain transition-transform duration-300 group-hover:scale-110" />
                </div>
                <span class="skill-name absolute -bottom-8 left-1/2 -translate-x-1/2 text-xs font-medium text-quinary opacity-0 group-hover:opacity-100 transition-opacity duration-300 bg-black/50 px-2 py-1 rounded-full backdrop-blur-sm">{{ skill.name }}</span>
              </div>
            </div>
          {% endif %}
        {% endfor %}
      </div>

      <!-- Scroll Indicator -->
      <div class="absolute bottom-10 left-1/2 transform -translate-x-1/2 z-30">
        <button onclick="scrollToNextSection()" class="animate-bounce flex flex-col items-center group cursor-pointer focus:outline-none">
          <span class="text-xs mb-2 text-quinary/70 group-hover:text-warning transition-colors">Explore more</span>
          <div class="relative w-8 h-12 rounded-full border-2 border-quinary/50 group-hover:border-warning p-1 transition-colors">
            <span class="absolute top-1 left-1/2 -translate-x-1/2 w-1 h-2 rounded-full bg-quinary/70 group-hover:bg-warning animate-scroll-dot transition-colors"></span>
          </div>
        </button>
      </div>
    </div>

    <style>
      /* Layout */
      #landing {
        display: flex;
        flex-direction: column;
        justify-content: center;
        background-attachment: fixed;
        overflow: hidden;
      }
      
      .bg-grid-pattern {
        background-image: linear-gradient(to right, rgba(255, 255, 255, 0.03) 1px, transparent 1px), linear-gradient(to bottom, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
      }
      
      /* Skill icon when overlapping text */
      .floating-skill.overlapping-text {
        opacity: 0.3 !important;
      }
      .floating-skill.overlapping-text:hover {
        opacity: 0.6 !important;
      }
      
      /* Animations */
      @keyframes float-particle {
        0%,
        100% {
          transform: translate(0, 0) rotate(0deg);
          opacity: 0.1;
        }
        25% {
          transform: translate(15px, -20px) rotate(5deg);
          opacity: 0.3;
        }
        50% {
          transform: translate(30px, 0) rotate(0deg);
          opacity: 0.1;
        }
        75% {
          transform: translate(15px, 20px) rotate(-5deg);
          opacity: 0.3;
        }
      }
      
      @keyframes spin-slow {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      
      @keyframes pulse-slow {
        0%,
        100% {
          opacity: 0.8;
        }
        50% {
          opacity: 1;
        }
      }
      
      @keyframes float {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-8px);
        }
      }
      
      @keyframes scroll-dot {
        0% {
          top: 4px;
          opacity: 0;
        }
        30% {
          opacity: 1;
        }
        70% {
          opacity: 1;
        }
        100% {
          top: 24px;
          opacity: 0;
        }
      }
      
      /* Utility classes */
      .animate-spin-slow {
        animation: spin-slow 50s linear infinite;
      }
      
      .animate-spin-slower {
        animation: spin-slow 80s linear infinite;
      }
      
      .animate-pulse-slow {
        animation: pulse-slow 5s ease-in-out infinite;
      }
      
      .animate-float {
        animation: float 5s ease-in-out infinite;
      }
      
      .animate-scroll-dot {
        animation: scroll-dot 2s ease infinite;
      }
      
      /* Interactive elements */
      .floating-skill:hover .skill-name {
        animation: float 3s ease-in-out infinite;
      }
      
      /* Smooth transitions */
      .transition-slow {
        transition: all 0.8s cubic-bezier(0.22, 1, 0.36, 1);
      }
    </style>
    <script>
      function scrollToNextSection() {
        // Get the current scroll position
        const currentPosition = window.pageYOffset || document.documentElement.scrollTop
      
        // Calculate the next section position (current position + viewport height)
        const nextPosition = currentPosition + window.innerHeight
      
        // Get the maximum scrollable height
        const maxHeight = document.documentElement.scrollHeight - window.innerHeight
      
        // Determine the target position (don't scroll beyond max height)
        const targetPosition = Math.min(nextPosition, maxHeight)
      
        // Smooth scroll to the target position
        window.scrollTo({
          top: targetPosition,
          behavior: 'smooth'
        })
      
        // If we're already at the bottom, redirect to /home as fallback
        if (currentPosition >= maxHeight - 10) {
          window.location.href = '/home'
        }
      }
      
      // Also make it work with wheel/touch events
      let isScrolling = false
      
      window.addEventListener(
        'wheel',
        function (e) {
          if (isScrolling) return
      
          // Only trigger on downward scroll near the bottom
          if (e.deltaY > 0 && window.innerHeight + window.pageYOffset >= document.documentElement.offsetHeight - 100) {
            isScrolling = true
            window.location.href = '/home'
          }
        },
        { passive: true }
      )
      
      window.addEventListener(
        'touchmove',
        function (e) {
          if (isScrolling) return
      
          // For touch devices, check if we're at the bottom
          if (window.innerHeight + window.pageYOffset >= document.documentElement.offsetHeight - 10) {
            isScrolling = true
            window.location.href = '/home'
          }
        },
        { passive: true }
      )
    </script>

    <style>
      @keyframes scroll-dot {
        0% {
          top: 4px;
          opacity: 0;
        }
        30% {
          opacity: 1;
        }
        70% {
          opacity: 1;
        }
        100% {
          top: 24px;
          opacity: 0;
        }
      }
      
      .animate-scroll-dot {
        animation: scroll-dot 2s ease infinite;
      }
      
      /* Make sure the button is tappable on mobile */
      @media (max-width: 640px) {
        .scroll-indicator-button {
          min-width: 44px;
          min-height: 44px;
        }
      }
    </style>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        // Initialize AOS animations with smoother settings
        AOS.init({
          duration: 1200,
          easing: 'ease-out-back',
          once: false,
          offset: 120,
          delay: 100
        })
      
        // Enhanced physics parameters
        const physics = {
          friction: 0.97,
          bounce: 0.9,
          pushForce: 0.25,
          skillRepulsion: 0.5
        }
      
        // Text sections to check for overlap
        const textSections = [document.getElementById('hero-text')]
      
        // Skill objects storage
        const skills = {}
        const skillElements = document.querySelectorAll('.floating-skill')
        const container = document.getElementById('skills-container')
        let containerRect = container.getBoundingClientRect()
      
        // Initialize skills with random positions and velocities
        skillElements.forEach((skill, index) => {
          const id = skill.dataset.skillId
          const size = skill.getBoundingClientRect()
      
          skills[id] = {
            element: skill,
            x: Math.random() * (containerRect.width - size.width),
            y: Math.random() * (containerRect.height - size.height),
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            width: size.width,
            height: size.height,
            isDragging: false,
            lastMouseDistance: Infinity
          }
      
          // Set initial position
          skill.style.left = `${skills[id].x}px`
          skill.style.top = `${skills[id].y}px`
        })
      
        // Mouse interaction variables
        let mouseX = 0
        let mouseY = 0
        let mouseRadius = 150 // Area of influence
        let isInteracting = false
      
        // Track mouse position
        container.addEventListener('mousemove', (e) => {
          const rect = container.getBoundingClientRect()
          mouseX = e.clientX - rect.left
          mouseY = e.clientY - rect.top
          isInteracting = true
        })
      
        container.addEventListener('mouseleave', () => {
          isInteracting = false
        })
      
        // Touch support
        container.addEventListener(
          'touchmove',
          (e) => {
            e.preventDefault()
            const touch = e.touches[0]
            const rect = container.getBoundingClientRect()
            mouseX = touch.clientX - rect.left
            mouseY = touch.clientY - rect.top
            isInteracting = true
          },
          { passive: false }
        )
      
        container.addEventListener('touchend', () => {
          isInteracting = false
        })
      
        // Drag functionality
        skillElements.forEach((skill) => {
          let isDragging = false
          let offsetX, offsetY
      
          skill.addEventListener('mousedown', (e) => {
            isDragging = true
            const id = skill.dataset.skillId
            skills[id].isDragging = true
      
            const rect = skill.getBoundingClientRect()
            offsetX = e.clientX - rect.left
            offsetY = e.clientY - rect.top
            skill.style.cursor = 'grabbing'
            skill.style.transition = 'none'
            skill.style.zIndex = '50'
          })
      
          document.addEventListener('mousemove', (e) => {
            if (!isDragging) return
      
            const id = document.querySelector('.floating-skill:hover')?.dataset.skillId
            if (!id) return
      
            const skill = skills[id]
            skill.x = e.clientX - containerRect.left - offsetX
            skill.y = e.clientY - containerRect.top - offsetY
      
            // Apply position
            skill.element.style.left = `${skill.x}px`
            skill.element.style.top = `${skill.y}px`
          })
      
          document.addEventListener('mouseup', () => {
            if (isDragging) {
              const id = document.querySelector('.floating-skill:hover')?.dataset.skillId
              if (id) {
                skills[id].isDragging = false
                // Give it a gentle push when released
                skills[id].vx = (Math.random() - 0.5) * 5
                skills[id].vy = (Math.random() - 0.5) * 5
              }
              isDragging = false
              document.querySelectorAll('.floating-skill').forEach((s) => {
                s.style.cursor = 'grab'
                s.style.transition = 'left 0.5s ease-out, top 0.5s ease-out'
                s.style.zIndex = '20'
              })
            }
          })
        })
      
        // Check for skill-to-skill collisions
        function checkSkillCollisions(skill, allSkills) {
          const skillRect = {
            x: skill.x,
            y: skill.y,
            width: skill.width,
            height: skill.height
          }
      
          Object.values(allSkills).forEach((otherSkill) => {
            if (skill === otherSkill || otherSkill.isDragging) return
      
            const otherRect = {
              x: otherSkill.x,
              y: otherSkill.y,
              width: otherSkill.width,
              height: otherSkill.height
            }
      
            // Simple collision detection
            if (skillRect.x < otherRect.x + otherRect.width && skillRect.x + skillRect.width > otherRect.x && skillRect.y < otherRect.y + otherRect.height && skillRect.y + skillRect.height > otherRect.y) {
              // Calculate repulsion force
              const dx = skillRect.x + skillRect.width / 2 - (otherRect.x + otherRect.width / 2)
              const dy = skillRect.y + skillRect.height / 2 - (otherRect.y + otherRect.height / 2)
              const distance = Math.sqrt(dx * dx + dy * dy)
      
              if (distance > 0) {
                const force = physics.skillRepulsion / distance
                skill.vx += dx * force
                skill.vy += dy * force
                otherSkill.vx -= dx * force
                otherSkill.vy -= dy * force
              }
            }
          })
        }
      
        // Check if element overlaps with any text section
        function checkTextOverlap(skill) {
          const skillRect = skill.element.getBoundingClientRect()
      
          for (const textSection of textSections) {
            if (!textSection) continue
      
            const textRect = textSection.getBoundingClientRect()
      
            // Check for overlap
            if (!(skillRect.right < textRect.left || skillRect.left > textRect.right || skillRect.bottom < textRect.top || skillRect.top > textRect.bottom)) {
              return true
            }
          }
          return false
        }
      
        // Animation loop
        function animate() {
          const containerWidth = containerRect.width
          const containerHeight = containerRect.height
      
          Object.values(skills).forEach((skill) => {
            if (skill.isDragging) return
      
            // Apply velocity
            skill.x += skill.vx
            skill.y += skill.vy
      
            // Mouse push effect (more subtle)
            if (isInteracting) {
              const dx = mouseX - (skill.x + skill.width / 2)
              const dy = mouseY - (skill.y + skill.height / 2)
              const distance = Math.sqrt(dx * dx + dy * dy)
      
              if (distance < mouseRadius && distance > 0) {
                const force = Math.pow((mouseRadius - distance) / mouseRadius, 2) * physics.pushForce
                skill.vx += (dx / distance) * force
                skill.vy += (dy / distance) * force
              }
            }
      
            // Boundary collision with damping
            if (skill.x < 0) {
              skill.x = 0
              skill.vx = -skill.vx * physics.bounce
            } else if (skill.x + skill.width > containerWidth) {
              skill.x = containerWidth - skill.width
              skill.vx = -skill.vx * physics.bounce
            }
      
            if (skill.y < 0) {
              skill.y = 0
              skill.vy = -skill.vy * physics.bounce
            } else if (skill.y + skill.height > containerHeight) {
              skill.y = containerHeight - skill.height
              skill.vy = -skill.vy * physics.bounce
            }
      
            // Apply friction
            skill.vx *= physics.friction
            skill.vy *= physics.friction
      
            // Check for skill collisions
            checkSkillCollisions(skill, skills)
      
            // Update position with smooth transition when not being dragged
            if (!skill.isDragging) {
              skill.element.style.left = `${skill.x}px`
              skill.element.style.top = `${skill.y}px`
            }
      
            // Check for text overlap and adjust opacity
            if (checkTextOverlap(skill)) {
              skill.element.classList.add('overlapping-text')
            } else {
              skill.element.classList.remove('overlapping-text')
            }
          })
      
          requestAnimationFrame(animate)
        }
      
        // Start animation
        animate()
      
        // Handle window resize
        function handleResize() {
          containerRect = container.getBoundingClientRect()
        }
      
        window.addEventListener('resize', handleResize)
      
        // Smooth scroll to next section
        const scrollIndicator = document.querySelector('.animate-bounce')
        if (scrollIndicator) {
          scrollIndicator.addEventListener('click', () => {
            window.scrollBy({
              top: window.innerHeight,
              behavior: 'smooth'
            })
          })
        }
      })
    </script>
  </div>
{% endblock %}
